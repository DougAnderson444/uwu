use crate::ast::{BlockStmt, Expr, Ident, Literal, Number, Program, Stmt};

/// A compiler will hold the AST of the input source.
pub struct Compiler {
    ast: Program,
}

/// Compiler implementation
impl Compiler {
    /// Create a new compiler instance.
    pub fn new(ast: Program) -> Self {
        Self { ast }
    }

    /// Execute AST to JS codegen. Returns javascript code.
    pub fn compile(&self) -> String {
        let mut source = "// Generated by uwu compiler v0.0\n".to_string();
        for stmt in &self.ast {
            if stmt == &Stmt::Blank {
                // PERF: swith to push() instead?
                source.push_str("\n");
                break;
            }

            let block: Option<String> = match stmt {
                Stmt::Expr(expr) => self.compile_expr(expr),
                _ => None,
            };

            if block.is_some() {
                source.push_str(&block.unwrap());
            }
        }
        source
    }

    fn compile_block(&self, ast: &BlockStmt) -> Option<String> {
        let mut source = String::new();
        for stmt in ast {
            if stmt == &Stmt::Blank {
                // PERF: swith to push() instead?
                source.push_str("\n");
                break;
            }

            let block: Option<String> = match stmt {
                Stmt::Expr(expr) => self.compile_expr(expr),
                _ => return None,
            };

            if block.is_some() {
                source.push_str(&block.unwrap());
            }
        }
        Some(source)
    }

    fn compile_expr(&self, expr: &Expr) -> Option<String> {
        let mut source = String::new();
        match expr {
            Expr::Let(ident, expr) => {
                let value = match self.compile_expr(expr) {
                    Some(value) => value,
                    None => return None,
                };
                let Ident(name) = ident;
                source.push_str(&format!("let {} = {}; \n", name, value));
            }
            Expr::Literal(lit) => {
                source.push_str(&self.compile_literal(lit)?);
            }
            Expr::Ident(Ident(expr)) => {
                source.push_str(expr);
            }
            Expr::Func { params, body, name } => {
                if let Some(Ident(ident)) = name {
                    source.push_str("function ");
                    source.push_str(ident);
                    source.push_str("(");
                    for param in params {
                        let Ident(n) = param;
                        source.push_str(n);
                        source.push_str(",");
                    }
                    source.push_str(") {");
                    source.push_str(&self.compile_block(body)?);
                    source.push_str("}");
                }
            }
            _ => return None,
        }
        Some(source)
    }

    fn compile_literal(&self, literal: &Literal) -> Option<String> {
        match literal {
            // Format a number from it's display trait.
            Literal::Number(val) => Some(self.compile_number(val)),
            // Format a string literal's value as "<val>".
            Literal::String(val) => Some(format!("\"{}\"", val)),
            Literal::Bool(val) => Some(val.to_string()),
            Literal::Array(val) => {
                let mut arr = "[".to_string();
                for exp in val {
                    if let Some(e) = self.compile_expr(exp) {
                        // Technically, [1, 1,] is valid javascript and does not throw syntax errors.
                        arr.push_str(&e);
                        arr.push_str(",");
                    }
                }
                arr.push_str("]");
                Some(arr)
            }
            Literal::Hash(val) => {
                let mut obj = "{".to_string();
                for (k, v) in val {
                    if let Some(e) = self.compile_expr(v) {
                        obj.push_str(&self.compile_expr(k)?);
                        obj.push_str(":");
                        obj.push_str(&e);
                        obj.push_str(",");
                    }
                }
                obj.push_str("}");
                Some(obj)
            }
            _ => None,
        }
    }

    fn compile_number(&self, val: &Number) -> String {
        match val {
            Number::Int(int) => format!("{}", int),
            Number::Float(flt) => format!("{}", flt),
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::compiler::*;
    use crate::parser::Parser;
    use crate::tokenizer::Lexer;

    #[test]
    fn compile_decl() {
        let source = "a = 1; b = \"hello world\"; c = true; d = [1, 2, 2]; e = { x: 1 }";
        let mut parser = Parser::new(Lexer::new(&source));
        let ast = parser.parse();
        let compiler = Compiler::new(ast);
        assert_eq!(compiler.compile(), "// Generated by uwu compiler v0.0\nlet a = 1; \nlet b = \"hello world\"; \nlet c = true; \nlet d = [1,2,2,]; \nlet e = {x:1,}; \n");
    }

    #[test]
    fn compile_fn() {
        let source = "fn add(x, y) { }";
        let mut parser = Parser::new(Lexer::new(&source));
        let ast = parser.parse();
        let compiler = Compiler::new(ast);
        assert_eq!(
            compiler.compile(),
            "// Generated by uwu compiler v0.0\nfunction add(x,y,) {}"
        );
    }
}
