use std::{cell::RefCell, fmt, rc::Rc};

use crate::env::Env;
use crate::macros::Macro;
use crate::{
    ast::{BlockStmt, Expr, Ident, Literal, Number, Program, Stmt},
    ltype,
    types::Type,
};

#[derive(Debug)]
pub enum ErrCode {
    /// Invalid type assignment
    UC01,
    /// Unexpected expression
    UC02,
    /// Not found in current scope
    UC03,
    /// Expected expression statement
    UC04,
}

impl fmt::Display for ErrCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ErrCode::UC01 => write!(f, "Invalid type assignment"),
            ErrCode::UC02 => write!(f, "Unexpected expression"),
            ErrCode::UC03 => write!(f, "Item not found in scope"),
            ErrCode::UC04 => write!(f, "Expected expression statement"),
        }
    }
}

impl ErrCode {
    pub fn invalid_type() -> Self {
        Self::UC01
    }

    pub fn unexpected_expr() -> Self {
        Self::UC02
    }

    pub fn not_found() -> Self {
        Self::UC03
    }

    pub fn expected_expr_stmt() -> Self {
        Self::UC04
    }
}

#[derive(Debug)]
pub struct CompilerError {
    pub code: ErrCode,
    pub loc: usize,
}

impl fmt::Display for CompilerError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.code)
    }
}

/// A compiler will hold the AST of the input source.
pub struct Compiler {
    ast: Program,
    scope: Rc<RefCell<Env>>,
}

/// Compiler implementation
impl Compiler {
    /// Create a new compiler instance.
    pub fn new(ast: Program) -> Self {
        Self {
            ast,
            scope: Rc::new(RefCell::new(Env::new())),
        }
    }

    /// Execute AST to JS codegen. Returns javascript code.
    pub fn compile(&self) -> Result<String, CompilerError> {
        let mut source = "// Generated by uwu compiler v0.0\n".to_string();
        for stmt in &self.ast {
            if stmt.0 == Stmt::Blank {
                source.push_str("\n");
                break;
            }

            match &stmt.0 {
                Stmt::Expr(expr) => {
                    let block = match self.compile_expr(expr) {
                        Err(code) => return Err(CompilerError { loc: stmt.1, code }),
                        Ok(b) => b,
                    };
                    source.push_str(&block);
                }
                _ => (),
            };
        }
        Ok(source)
    }

    fn compile_block(&self, ast: &BlockStmt) -> Result<String, ErrCode> {
        let mut source = String::new();
        for stmt in ast {
            if stmt.0 == Stmt::Blank {
                // PERF: swith to push() instead?
                source.push_str("\n");
                break;
            }

            let block: String = match &stmt.0 {
                Stmt::Expr(expr) => self.compile_expr(expr)?,
                Stmt::Return(expr) => {
                    source.push_str("return ");
                    self.compile_expr(expr)?
                }
                _ => continue,
            };

            source.push_str(&block);
        }
        Ok(source)
    }

    fn compile_expr(&self, expr: &Expr) -> Result<String, ErrCode> {
        let mut source = String::new();
        match expr {
            Expr::Let(ident, expr) => {
                let value = self.compile_expr(expr)?;
                let Ident(name) = ident;
                if let Expr::Literal(e) = expr.as_ref() {
                    self.scope.borrow_mut().addt(name, e);
                } else {
                    self.scope.borrow_mut().sett(name, Type::Unknown);
                }
                source.push_str(&format!("let {} = {}; \n", name, value));
            }
            Expr::Assign(v, expr) => {
                let value = self.compile_expr(expr)?;
                let name = self.compile_expr(v)?;
                if let Expr::Literal(e) = expr.as_ref() {
                    let mut b = self.scope.borrow_mut();
                } else {
                    self.scope.borrow_mut().sett(&name, Type::Unknown);
                }
                source.push_str(&format!("{} = {}; \n", name, value));
            }
            Expr::Prefix(prefix, expr) => {
                let value = self.compile_expr(expr)?;
                let pre = format!("{}", prefix);
                source.push_str(&pre);
                source.push_str(&value);
            }
            Expr::Infix(infix, e1, e2) => {
                let e1 = self.compile_expr(e1)?;
                let e2 = self.compile_expr(e2)?;
                let infix = format!("{}", infix);

                source.push_str(&e1);
                source.push_str(&infix);
                source.push_str(&e2);
            }
            Expr::Index(exp1, exp2) => {
                let e1 = self.compile_expr(exp1)?;
                let e2 = self.compile_expr(exp2)?;
                source.push_str(&e1);
                source.push_str("[");
                source.push_str(&e2);
                source.push_str("]");
            }
            Expr::Accessor(expr1, expr2) => {
                let e1 = self.compile_expr(expr1)?;
                source.push_str(&e1);
                let Ident(name) = &expr2;
                source.push_str(".");
                source.push_str(&name);
            }
            Expr::Literal(lit) => {
                source.push_str(&self.compile_literal(lit)?);
            }
            Expr::Ident(Ident(expr)) => {
                source.push_str(expr);
            }
            Expr::Func { params, body, name } => {
                if let Some(Ident(ident)) = name {
                    source.push_str("function ");
                    source.push_str(ident);
                    source.push_str("(");
                    self.scope.borrow_mut().add_fn(ident.into());
                    for (i, param) in params.iter().enumerate() {
                        let Ident(n) = param;
                        source.push_str(n);
                        if i == params.len() - 1 {
                            break;
                        }
                        source.push_str(",");
                    }
                    source.push_str("){");
                    source.push_str(&self.compile_block(body)?);
                    source.push_str("}");
                }
            }
            Expr::Call { func, args } => {
                let function = &self.compile_expr(func)?;
                if !self.scope.borrow_mut().has_fn(function.into()) {
                    return Err(ErrCode::not_found());
                };
                source.push_str(function);
                source.push_str("(");
                for (i, arg) in args.iter().enumerate() {
                    source.push_str(&self.compile_expr(arg)?);
                    if i == args.len() - 1 {
                        break;
                    }
                    source.push_str(",");
                }
                source.push_str(");");
            }
            Expr::Macro { name, args } => {
                let function = &self.compile_expr(name)?;
                let m = Macro::from_name(function).ok_or(ErrCode::UC01)?;
                match m.expand(args) {
                    Some(m) => source.push_str(&m),
                    None => return Err(ErrCode::UC01),
                }
            }
            Expr::Regexp { pattern, flags } => {
                source.push_str("/");
                source.push_str(&self.compile_expr(pattern)?);
                source.push_str("/");
                if let Some(Ident(fl)) = flags {
                    source.push_str(&fl);
                }
            }
            Expr::While { cond, consequence } => {
                let cnd = &self.compile_expr(cond)?;
                let consq = &self.compile_block(consequence)?;
                source.push_str("while(");
                source.push_str(cnd);
                source.push_str("){");
                source.push_str(consq);
                source.push_str("}");
            }
            Expr::If {
                cond,
                consequence,
                alternative,
            } => {
                let cnd = &self.compile_expr(cond)?;
                let consq = &self.compile_block(consequence)?;
                source.push_str("if(");
                source.push_str(cnd);
                source.push_str("){");
                source.push_str(consq);
                source.push_str("}");
                if alternative.is_some() {
                    let alt = &self.compile_block(alternative.as_ref().unwrap())?;
                    source.push_str("else{");
                    source.push_str(alt);
                    source.push_str("}");
                }
            }
        }
        Ok(source)
    }

    fn compile_literal(&self, literal: &Literal) -> Result<String, ErrCode> {
        match literal {
            // Format a number from it's display trait.
            Literal::Number(val) => Ok(self.compile_number(val)),
            Literal::String(val) => Ok(val.to_string()),
            Literal::Bool(val) => Ok(val.to_string()),
            Literal::Array(val) => {
                let mut arr = "[".to_string();
                for (i, exp) in val.iter().enumerate() {
                    let e = self.compile_expr(exp)?;
                    arr.push_str(&e);
                    if i == val.len() - 1 {
                        break;
                    }
                    arr.push_str(",");
                }
                arr.push_str("]");
                Ok(arr)
            }
            Literal::Hash(val) => {
                let mut obj = "{".to_string();
                for (i, (k, v)) in val.iter().enumerate() {
                    let e = self.compile_expr(v)?;
                    obj.push_str(&self.compile_expr(k)?);
                    obj.push_str(":");
                    obj.push_str(&e);
                    if i == val.len() - 1 {
                        break;
                    }
                    obj.push_str(",");
                }
                obj.push_str("}");
                Ok(obj)
            }
        }
    }

    fn compile_number(&self, val: &Number) -> String {
        match val {
            Number::Int(int) => format!("{}", int),
            Number::Float(flt) => format!("{}", flt),
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::compiler::*;
    use crate::parser::Parser;
    use crate::tokenizer::Lexer;

    fn c(source: &str) -> String {
        let mut parser = Parser::new(Lexer::new(source));
        let ast = parser.parse();
        let compiler = Compiler::new(ast);
        compiler.compile().unwrap()
    }

    #[test]
    fn compile_decl() {
        let source =
            "let a = 1; let b = \"hello world\"; let c = true; let d = [1, 2, 2]; let e = { x: 1 }";
        assert_eq!(c(source), "// Generated by uwu compiler v0.0\nlet a = 1; \nlet b = \"hello world\"; \nlet c = true; \nlet d = [1,2,2]; \nlet e = {x:1}; \n");
    }

    #[test]
    fn compile_mut_decl() {
        let source = "let a = 1; a = a + 1 / 2";
        assert_eq!(
            c(source),
            "// Generated by uwu compiler v0.0\nlet a = 1; \na = a+1/2; \n"
        );
    }

    #[test]
    fn compile_fn() {
        let source = "fn add(x, y): end";
        assert_eq!(
            c(source),
            "// Generated by uwu compiler v0.0\nfunction add(x,y){}"
        );
    }

    #[test]
    fn compile_fn_return() {
        let source = "fn add(x, y): return 0 end";
        assert_eq!(
            c(source),
            "// Generated by uwu compiler v0.0\nfunction add(x,y){return 0}"
        );
    }

    #[test]
    fn compile_call() {
        let source = "fn add(x, y): return x + y end add(1, 2)";
        assert_eq!(
            c(source),
            "// Generated by uwu compiler v0.0\nfunction add(x,y){return x+y}add(1,2);"
        );
    }

    #[test]
    fn compile_while() {
        let source = "fn print(): end while(true): print(1) end";
        assert_eq!(
            c(source),
            "// Generated by uwu compiler v0.0\nfunction print(){}while(true){print(1);}"
        );
    }

    #[test]
    fn compile_if() {
        let source = "fn print(): end if(true): print(1); end";
        assert_eq!(
            c(source),
            "// Generated by uwu compiler v0.0\nfunction print(){}if(true){print(1);}"
        );
    }

    #[test]
    fn compile_if_else() {
        let source = "if(x): else: end";
        assert_eq!(
            c(source),
            "// Generated by uwu compiler v0.0\nif(x){}else{}"
        );
    }

    #[test]
    fn compile_prefix_expr() {
        let source = "!x";
        assert_eq!(c(source), "// Generated by uwu compiler v0.0\n!x");
    }

    #[test]
    fn compile_infix_expr() {
        let source = "x + 2 - 1";
        assert_eq!(c(source), "// Generated by uwu compiler v0.0\nx+2-1");
    }

    #[test]
    fn compile_index_expr() {
        let source = "x[1]";
        assert_eq!(c(source), "// Generated by uwu compiler v0.0\nx[1]");
    }
}
